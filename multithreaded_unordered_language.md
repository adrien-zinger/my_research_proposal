# Title

Design and realisation of a multithreaded unordered expression language for
adaptive execution and queueing theory applications.

# Abstract
The mainline of this research is the design and development of a
programming language with a inherent concurrent paradigm. That language will be
primarily based on a runtime with a multithreaded approach, the program generate
for each expression one or several jobs that are fundamentally unordered
evaluated. That new language aims to be flexible, easy to learn, and contains
powerful features, providing opportunities to model and analyze complex
systems. That multithreaded paradigm enable runtime adaptation of execution, job
class specifications, that can be used both in a real-world environment for
backend developments requiring parallelism, and in a study environment to
experiment some networks in queueing theory.

That multi-threaded paradigm enable runtime adaptation of execution, job
class specifications, that can be used both in a real-world environment for
backend developments requiring parallelism, and in a study environment to
experiment some networks in queueing theory.

# Introduction

In traditional programing language, the basic paradigm is strict ordering of
expressions evaluation. This is what the front-end of C and C++ propose, and
the output generated by such programs reflets what the developper require.
In other functionnal programing languages, like in Rust and Haskell, there is
much to tell because they introduce both a parallelism with lazy evaluations.
But none primarly target multithreading or environmental adaptation as the
proposed language here.

It has been shown that making evaluation unordered in a program can be very
powerfull. In many context in high level, the development of a system tends to use threads,
corroutines, futures, promises, etc. At low levels, compilers, like GCC aims to reorder some
expressions to make generated machine code faster based on the build envirronment.
At a lower level, an out-of-order processor is able to evaluate expressions of the same
program if no fences are detected. The implementation of a language where parallel evaluation
is the inherent paradigm makes sens, but it can be difficult for the developper to understand
what his code actually do.

The language design has to be easy to use to make development of complex system possible. Generally a
code is interpreted sequencially, they are severals reason for that but one of them is that developpers
thinks sequencially. If Haskell is known as a hard to learn language because of his features of concurrency and lazy
evaluation and so on, in a very wildly used language like javascript, concurrency is used
in any context by any programmers, beginners to masters. This is because in javascript, the
concurrency is monothreaded and managed by a virtual machine which makes accesses to the memory
safe. In that kind of context, a developper can built a very complex systems of states machines
with a large scale of jobs.

> - [Comparative Study of Refactoring Haskell and Erlang Programs](https://www.researchgate.net/publication/220703707_Comparative_Study_of_Refactoring_Haskell_and_Erlang_Programs)
> - [Kyle Simpson- You Don't Know JS, Async and Performance](https://drive.google.com/file/d/1q-FkIvx6oBEcZ-pli_jkFFPr6B7d7VBA/view)

There is a growing need for programming paradigms to have one that inherently implement
concurrency and adaptable modeling. Rust and C++ both provides library that are limited
by what these language propose to create a program. It's known that bigger a system is,
harder it became to change how it works. Many projects suffer of big refactorings because
of the dependance of a library. Rust proposal of defining async/await behaviour is not
enough and is today controversal.

> - [The Rust I wanted had no future](https://news.ycombinator.com/item?id=36193326)
> - [Experimental async / await support for Tokio](https://tokio.rs/blog/2018-08-async-await)

While multithreading programming is becomming a wildly used approach to design a system, due
to the observed performance and the global ideology spreed by developper's influencers. There
is still open issues, partially resolved for fitting with specific cases. The opportunity to
use previous mistakes as lesson is very interesting in this research. In real-world applications,
promises implementation shown to be quite difficult, and category theory demonstrate another
controversial way which finally is considered better than before. Tokio crate faced at
stuttering and big latency issues, which were patched but still very rigid.

> - [CLR thread pool injection, stuttering problems](https://joeduffyblog.com/2006/07/08/clr-thread-pool-injection-stuttering-problems/)
> - [Jon Gjengset - Decrusting the tokio crate](https://www.youtube.com/watch?v=o2ob8zkeq2s)
> - [Category Theory Promise/A+](https://brianmckenna.org/blog/category_theory_promisesaplus)
> - [Reducing tail latencies with automatic cooperative task yielding](https://tokio.rs/blog/2020-04-preemption)

This research aims to design a new language with a complete toolchain (static analyser, interpreter
and transpiler into C89) where every expression are fundamentally unordered jobs, written like if it were
sequential, with lazy evaluation and inherent parallelism.

# Research Questions

1. How to design a language to treat all expressions in any order without sacrificing correctness
   and linearizability conditions?

The language should be able to recognize pure and impure function to minimize the use of mutexes. Early
in the code analysis, the toolchain must recognize static, immutable and mutable variables to mitigate
the access overhead to the memory shared between threads.

> - [Implementation Strategies for Mutable Value Semantics](https://www.jot.fm/issues/issue_2022_02/article2.pdf)
> - [Pure vs Impure functions](https://dev.to/sanspanic/pure-vs-impure-functions-50aj)
> - [Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms](https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf)
> - [Rayon data parallelism](https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/)

2. What mechanisms can allow the runtime system to reorder expression evaluation
based on the execution context?

Said that the language in this research aims to be used in real-world and study environment, the runtime
has to dynamically reorder expression evaluation. The development of a program must be handful to tell
that a job has a higher/less priority than another. Most of the needs here have to be defined after studying
the state of art in queueing theory.

> - [Making the Tokio scheduler 10x faster](https://tokio.rs/blog/2019-10-scheduler)

3. How can the language's runtime serve as a realistic environment for modeling
and testing queueing systems?

In first part of the design, multithreading and concurrent systems require such mechanisms
like `wait_all`, `then`, `timeout` to be implemented. In the other hand, the toolchain must
contains handful tools to compare performances by slightly modifying job classes, runtime
configurations and jobs implementations. The code have to not be broken at each refoctoring
of the global behavior of the system. Finally, insights about program's performances are often hard
to get when a project scale and inherent functionalities are big requirements in real-world applications
and in study cases.

> - [A Product-form Network for Systems with Job Stealing Policies](https://dl.acm.org/doi/10.1145/3643845)
> - [The Gittins Policy is Nearly Optimal in the M/G/k under Extremely General Conditions](https://www.cs.cmu.edu/~harchol/Papers/Sigmetrics21a.pdf)

# Objectives

The goals are:

1. To design a complete prototype of a language and his toolchains with some
libraries as network communication, input and outputs, parsing, etc. Directly binded with
libc.

2. Develop benchmark's programs with the designed language and other traditional
   approach (C, C++, Haskell, Rust)

3. After an evaluation of the addptability/flexibility of the language.
   Apply different models of queueing theory, analyse and compare scenarios.

> - [First attempt of the prototype](https://github.com/adrien-zinger/eniem-langage)
> - [No-op compiler benchmarking](https://scot.tg/2025/01/07/no-op-compiler-benchmarking/)

# Methodology

1. Language specification. Define the syntax and the semantics of the language.
2. Create a scalable interpreter capable to read and execute a program.
3. Design some cases studies and benchmarks involving computation tasks and
   queueing models.
4. Evaluation metrics, parallel execution efficiency, context switching
   overhead, runtime latency, linearizability and correctness guarantees.


# Contributions to computer science

- A new language that primarly use multithreading, lazy evaluation and unordered computation.
- New techniques for experimental platforms in queueing theory.
- New techniques for real-world scalable applications development.
- Complete toolchain with type checking, abstract interpretation, interpreter and compiler.
- Implementation of benchmarks of queueing networks with job stealing (multiple jobs queues),
  single queue with/out jobs reordering.
- Insights to the interplay between program evaluation order and system performance.

# Timeline

Phases                        | Duration (Months)
Literature Review & Design    | 0–6
Prototype Development         | 7–18
Experimental Design & Testing | 19–30
Analysis                      | 31–36
Dissertation Writing          | 37–42
Defense Preparation           | 43–48

